# Introduction 
 this is tariq Abu kharmh
  i am 24 year i am in last smester for finishing my B's degree at **Software Eng** in **Wise Unevirsty**
  i am in love with programming since i was 18 year the story start when i was playing Cs go 
  and the game crashed then i decide to youtube it for solving the issue that error sparks my intrest on coding and see what happen behind the siance 



  




 ## Developer mindset 
 ![image](https://cdn-media-1.freecodecamp.org/images/0*9aI9Xrj0_SpE9KbK.jpg)

 Here is some keypoint that exery **Deveoper**  must **master** :

 ## **1. Conceiving The Purpose of Software**
  **purpose** of all software: To help people
  Developers who cannot conceive the purpose of the software will write bad software. What is bad software? A complex system that doesn’t help people that much.



## **2. The Goals of Software Design**
### Every programmer is a designer.

The design of software aims to make developers job as easy as possible so they can focus on what matters. You will create software that will help users and your software will continue to help them for a long time.

## **3. (Mis)understanding**

Developers who don’t fully understand their work tend to develop complex systems. It can become a vicious cycle: misunderstanding leads to complexity

## **4. Simlicity**


### Simplicity is the ultimate sophistication

Programming is the act of reducing complexity to simplicity. A “bad developer” is just somebody who fails to reduce complexity. A “good developer” is doing everything in their power to make the code as simple as possible for other programmers.

## **5. Complexity**

The source of many software failures is complexity. You start out with a simple project that can be completed in one month. Then you add complexity, and the task will take up to three months. Then you start to add features that fulfill some other purpose. Things get very complex because you expand your software purpose for no reason. The tasks will take six months.

## **6. Maintenance**

Maintenance is one of the most important things in software development. Unfortunately, developers usually ignore how important it is. Quick coding and fast shipping look more important than code maintenance. This is the point where they make a mistake  ignorance of future code maintenance.
x   

## **8. Prioritizing**

When you face many possible directions, how do you decide which option is the best? What to focus on and which features you should implement?

To answer those questions, there are three important factors that will help you make a better decision.

- The desirability of a change (D)

- The value of a change (V)

- The effort required to perform the change (E)


## The equation is simple: **D=V/E**



 ## **9. Solving Problems**

 The first step is understanding. Know exactly what is being asked. Most hard problems are hard because you don’t understand them. Write down your problem and try to explain it to someone else.


**think twice code once**

## **10. Good enough is fine**

They start by thinking of every small detail they could think about. Then assumptions and predictions come along followed by “What if” sentences. They have to predict the future because they were now so captivated by the imagination of the project in their mind and their project has to be as perfect as they imagined it.

Actually, they are not aware of what’s waiting for them and how much it will cost them by chasing perfection.

Let me tell you what will happen:

- You will be writing code that isn’t needed
- You will increase complexity by adding unnecessary codes
- You will be too generic
- You will be missing deadlines
- You will be dealing with many bugs caused by the complexity

## **11. Predictions**

You can’t predict the future, so no matter how generic your solution is, it will not be generic enough to satisfy the actual future requirements you will have. Most probably, this time will never come and the code you wrote to solve future problems will increase complexity, make it hard to change the pieces of code and eventually it will become a burden that may destroy your software.

**Being too generic involves a lot of code that isn’t needed.**

## **12. Assumptions**

“An **assumption** is something that you accept as true or suppose to be true, although you have no conclusive proof.”

assumption can kill a software project by making the software has unnecessary codes that make it hard to throw away because everything is intertwined. It takes months to refactor the code and now they think to rewrite the whole software from scratch which will cause them to lose months.

 ## Tip to a void assumption 
 ### **Code should be designed based on what you know now, not on what you think will happen in the future**

 ## **13. Stop Reinventing**

 you’re going to be spending a lot of time working on the garbage collector, when you could just be working on your software.

The only times it’s okay to reinvent the wheel is when any of the following are true:

- You need something that doesn’t exist yet
- All of the existing “wheels” are bad technologies or incapable of handling your needs
- The existing “wheels” aren’t being properly maintained

## simple rule 
### **Don’t reinvent the wheel.**

## **14. Resistance**

Always resist adding more code, more features until you are convinced that they are required and there is a need to implement them. Because unnecessary changes will increase defects in your software.

## **15. Automation**

Don’t spend your time on repetitive tasks. Set them up and forget about them.
 
**If you can automate it, automate it.**


## **16. Code measurement**

more code lines  doesnt mean tha is better . 
The optimum code is a small bunch of code that is easy to understand, easy to read.


## **17. Productivity**


**Your main goal should be keeping your code base as small as possible.**


## **18. Testing**

You should be reliable. When other developers in your team see that you committed new code to source control, everyone should know that your code is tested, and works.



## **19. (Under)Estimation**


**Developers’ estimation sucks.**

Usually, they underestimate things rather than overestimate them. They underestimate the time and effort required to develop a small amount of code or a feature. In the end, this underestimation leads to missing deadlines

**The solution:** Break the big thing into smaller things.


## **20. Running Away From Rewriting**


**Rewriting code is often a developer delusion, not the solution in most cases.**



## **21. Documentation and Commenting**


One of the common misconceptions about commenting is that developers add comments that say what code is doing.This is wrong

The real purpose of comments is to explain **“WHY”** you did something, not **“WHAT”** the code is doing.


## **22. Picking Technologies (Tools, Libraries, etc.)**


**Don’t depend on external technologies. But when you have to do so, try to reduce your dependency on them as much as you can.**


There are a few factors you should consider before you start using some technology:

- Is there active development behind it?
- Will it continue to be maintained?
- How easy is it to switch away from?
- What does the community say about it?


## **23. Self-Development**


ry out different programming languages and tools, read books on software development. They will give you another perspective.

**Every day small improvements will make a real difference in your knowledge and skills.**


## **24. Don’t be a hero**


A lot of times it’s better to be a quitter than a hero. As Jason Fried explains,
So you go into hero mode. You’re determined to make it work (and slightly embarrassed that it isn’t already working). You grab your cape and shut yourself off from the world.

**Don’t be obsessive. Know when to quit. Don’t hesitate to ask for help.**


## **25. Don’t Ask Questions… Ask For Help**



When you have tried everything, and preferably after you have a working solution, now is the best time to seek advice. Look to peers and senior developers to review your code.




















